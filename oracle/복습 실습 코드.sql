--125p Q1.

SELECT *
FROM EMP
WHERE ENAME LIKE '%S';

--Q2.

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE JOB = 'SALESMAN';

--03.
-- 집합 연산자를 사용하지 않은 방식
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO IN(20,30) AND SAL>2000;

-- 집합 연산자를 사용한 방식
SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 20 AND SAL>2000

UNION

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 30 AND SAL>2000;

--Q4.

 SELECT *
 FROM EMP 
 WHERE SAL NOT BETWEEN 2000 AND 3000;

--Q5. 

SELECT ENAME, EMPNO, SAL, DEPTNO
FROM EMP
WHERE ENAME LIKE '%E%' 
  AND DEPTNO = 30
  AND SAL NOT BETWEEN 1000 AND 2000;


--Q6

 SELECT *
 FROM EMP
 WHERE COMM IS NULL
 AND MGR IS NOT NULL
 AND JOB IN('MANAGER','CLERK')
 AND ENAME NOT LIKE '_L%';
 
 
 -- TEST ZONE
 
 SELECT JOB, SUBSTR(JOB,1,2), SUBSTR(JOB,3,2), SUBSTR(JOB,5)
FROM EMP;



SELECT *
FROM EMP
WHERE INSTR(ENAME,'S') > 0;

SELECT ROUND(1234.5678) AS ROUND,
    ROUND(1234.5678, 0) AS ROUND_0,
    ROUND(1234.5678, 1) AS ROUND_1,
    ROUND(1234.5678, 2) AS ROUND_2,
    ROUND(1234.5678, -1) AS ROUND_MINUS1,
    ROUND(1234.5678, -2) AS ROUND_MINUS2
FROM DUAL;


SELECT *
FROM EMP
WHERE SAL BETWEEN 1250 AND 1500;

DESC EMP;

SELECT HIREDATE
FROM EMP;


SELECT '100,000' - '50,000'
FROM DUAL;

SELECT SUM(SAL) AS 급여총액,
       AVG(SAL) AS 급여평균,
       MAX(SAL) AS 최대급여,
       MIN(SAL) AS 최소급여
FROM EMP;

SELECT COUNT(*)
FROM EMP;

SELECT JOB
FROM EMP;


SELECT JOB
FROM EMP
ORDER BY JOB;

SELECT COUNT(JOB)
FROM EMP;

SELECT COUNT(DISTINCT JOB) AS "직업 종류의 개수"
FROM EMP;

SELECT ENAME, MAX(SAL)
FROM EMP;

SELECT AVG(SAL), '222' AS DEPTNO
FROM EMP
WHERE DEPTNO = 10
UNION ALL
SELECT AVG(SAL), '20' AS DEPTNO
FROM EMP
WHERE DEPTNO = 20
UNION ALL
SELECT AVG(SAL), '30' AS DEPTNO
FROM EMP
WHERE DEPTNO = 30;


SELECT AVG(SAL),DEPTNO
FROM EMP
GROUP BY DEPTNO;


SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;


SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL)>=2000;

SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
WHERE AVG(SAL) >= 2000
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

SELECT ENAME, SAL
FROM EMP
WHERE SAL > AVG(SAL);  -- 오류: 집계 함수는 WHERE 절에서 사용할 수 없음


SELECT DEPTNO,ENAME, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, ENAME;


SELECT DEPTNO,ENAME
FROM EMP
GROUP BY DEPTNO;

SELECT LISTAGG(ENAME, ' ')
WITHIN GROUP(ORDER BY SAL DESC)
FROM EMP;


SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL >= 3000;


SELECT *
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;


SELECT E1.EMPNO, E1.ENAME, E1.MGR,
E2.EMPNO AS MGR_EMPNO,
E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON(E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

SELECT ENAME
FROM EMP
WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO = 30);

SELECT ENAME
FROM EMP
WHERE SAL > SOME (SELECT SAL FROM EMP WHERE DEPTNO = 30);



-- ===================================

-- 사원 이름이 JONES인 사원의 급여 출력하기

SELECT SAL
FROM EMP
WHERE ENAME = 'JONES';

-- 급여가 2975보다 높은 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL > 2975;

-- 서브쿼리로 JONES의 급여보다 높은 급여를 받는 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL > (
	SELECT SAL
	FROM EMP
	WHERE ENAME = 'JONES');
    

-- EMP 테이블에서 SCOTT보다 빨리 입사한 사원 목록 출력하기

SELECT *
FROM EMP
WHERE HIREDATE > (
	SELECT HIREDATE
	FROM EMP
	WHERE ENAME = 'SCOTT');

-- 20번 부서에 속한 사원 중 전체 사원의 
-- 평균 급여보다 높은 급여를 받는 사원 
-- 정보와 소속 부서 정보를 출력하기

SELECT *
FROM EMP
WHERE DEPTNO = 20
AND SAL > (
	SELECT AVG(SAL)
	FROM EMP);

SELECT *
FROM EMP
WHERE DEPTNO = 20
AND  SAL > (
    SELECT AVG(SAL)
    FROM EMP
);


SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = 20
    AND E.DEPTNO = D.DEPTNO
    AND  SAL > (
        SELECT AVG(SAL)
        FROM EMP
    );

-- IN 연산자 사용하기
-- 부서 번호가 20이거나 30인 사원의 정보를 출력하기

SELECT *
FROM EMP
WHERE DEPTNO IN(20,30);

-- 각 부서별 최고 급여와 동일한 급여를 받는 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL in(
	SELECT MAX(SAL)
	FROM EMP
    GROUP BY DEPTNO
    );
    
SELECT *
FROM EMP
WHERE SAL IN (
    SELECT MAX(SAL)
    FROM EMP
    GROUP BY DEPTNO
);    

-- ANY 연산자 사용하기
-- 각 부서별 최고 급여와 동일한 급여를 받는 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL ANY(
	SELECT MAX(SAL)
	FROM EMP);

-- SOME 연산자 사용하기
-- 각 부서별 최고 급여와 동일한 급여를 받는 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL in(
	SELECT SOME(SAL)
	FROM EMP);

-- 30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL < (
	SELECT MAX(SAL)
	FROM EMP
	WHERE DEPTNO = 30);

-- 30번 부서 사원들의 최소 급여보다 많은 급여를 받는 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL > (
	SELECT MIN(SAL)
	FROM EMP
	WHERE DEPTNO = 30);

-- 30번 부서 사원들의 최소 급여보다 더 적은 급여를 받는 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL < (
	SELECT MIN(SAL)
	FROM EMP
	WHERE DEPTNO = 30);

-- 30번 부서 사원들의 최대 급여보다 더 많은 급여를 받는 사원 정보 출력하기

SELECT *
FROM EMP
WHERE SAL > (
	SELECT MAX(SAL)
	FROM EMP
	WHERE DEPTNO = 30);


SELECT *
FROM SALGRADE;

SELECT *
FROM EMP;

SELECT DEPTNO AS "부서 번호", AVG(SAL) AS "급여 평균"
FROM EMP;

SELECT DEPTNO AS "부서 번호", AVG(SAL) AS "급여 평균"
FROM EMP
GROUP BY DEPTNO;

-- 다중 컬럼을 이용하여 그룹별로 출력하기

SELECT DEPTNO, JOB, COUNT(*), SUM(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

 SELECT JOB, SUM(SAL)
 FROM EMP
 WHERE NOT JOB = 'MANAGER'
 GROUP BY JOB
 HAVING SUM(SAL) >= 5000
 ORDER BY JOB;
 
 -- 부서별 평균 급여 중 최고 급여 출력하기

SELECT JOB, MAX(SAL)
FROM EMP
GROUP BY JOB
HAVING MAX(SAL);

-- 부서별 평균 급여 중 최고 급여 출력하기

SELECT MAX(AVG(SAL))
FROM EMP
GROUP BY DEPTNO;

-- Q4. 사원번호가 7788인 사원의 이름과 소속 부서명을 출력하기

SELECT E.ENAME, D.DNAME
FROM EMP E, DEPT D
WHERE E.EMPNO = 7788;

-- Q4. 사원번호가 7788인 사원의 이름과 소속 부서명을 출력하기

SELECT E.ENAME, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.EMPNO = 7788;

-- Q5. 사원별로 급여 등급을 출력하기 (컬럼은 사원이름,급여,등급만 표시해주세요.)

SELECT E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S;

-- Q5. 사원별로 급여 등급을 출력하기 (컬럼은 사원이름,급여,등급만 표시해주세요.)

SELECT E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S
WHERE SAL BETWEEN LOSAL AND HISAL;

-- Q6. 사원의 이름과 소속된 부서의 이름과 급여, 급여가 몇 등급인지를 출력하기

SELECT E.ENAME, D.DNAME, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO
AND SAL BETWEEN LOSAL AND HISAL;

select e.ename, d.dname,e.sal, s.grade
from emp e, dept d, salgrade s
where e.deptno = d.deptno 
    and e.sal between s.losal and s.hisal;
    
    -- 사원이름과 직속 상관 이름을 출력하기

SELECT E1.ENAME, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

-- JION ~ ON절을 사용하여 출력하기
SELECT  E1.ENAME || '의 직속 상관은 ' || E2.ENAME
FROM EMP E1 JOIN EMP E2 ON E1.MGR = E2.EMPNO;

-- Q12. 직급이 SALESMAN 이 아니면서 급여가 임의의 SALESMAN 보다 
--급여가 낮은 사원의 사원번호,이름,직급,급여를 출력하기

SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE JOB != 'SALESMAN'
AND SAL < (
	SELECT SAL
	FROM EMP
	WHERE JOB = 'SALESMAN'
	);
    
    -- Q12. 직급이 SALESMAN 이 아니면서 급여가 임의의 SALESMAN 보다 
--급여가 낮은 사원의 사원번호,이름,직급,급여를 출력하기

SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE JOB != 'SALESMAN'
AND SAL < ANY(
	SELECT SAL
	FROM EMP
	WHERE JOB = 'SALESMAN'
	);
    
    -- 서브쿼리 결과 값이 존재하지 않는 경우
SELECT *
FROM EMP
WHERE EXISTS (
    SELECT DNAME
    FROM DEPT
    WHERE DEPTNO = 50
);  





-- 복습 코딩 테스트

--Q1.

SELECT *
FROM EMP
WHERE SAL>=1500;

SELECT *
FROM EMP
WHERE NOT SAL <1500;

--Q2.

SELECT *
FROM EMP
WHERE DEPTNO = 10;

SELECT *
FROM EMP
WHERE DEPTNO NOT IN(20,30);

SELECT *
FROM EMP
WHERE DEPTNO !=20
AND DEPTNO !=30;

SELECT *
FROM EMP
WHERE EMPNO IN (
    SELECT EMPNO 
    FROM EMP 
    WHERE DEPTNO NOT IN (20, 30)
);

SELECT *
FROM EMP
WHERE CASE 
          WHEN DEPTNO = 10 THEN 1 
          ELSE 0
      END = 1;
      
SELECT *
FROM EMP
WHERE DEPTNO IN(10);

--Q3.

SELECT *
FROM EMP
WHERE ENAME = 'SCOTT';

SELECT *
FROM EMP
WHERE ENAME LIKE 'SCOTT';

--Q4.

SELECT *
FROM EMP
WHERE HIREDATE <= DATE '1981-01-01';

SELECT *
FROM EMP
WHERE HIREDATE BETWEEN DATE '1900-01-01' AND DATE '1981-01-01';

SELECT *
FROM EMP
WHERE HIREDATE <= TO_DATE('1981-01-01', 'YYYY-MM-DD');

--Q5

SELECT *
FROM EMP
WHERE DEPTNO = 10 
AND JOB = 'MANAGER';

--Q6

SELECT *
FROM EMP
WHERE DEPTNO = 10 
OR JOB = 'MANAGER';

--Q7

SELECT *
FROM EMP
WHERE DEPTNO != 10;

SELECT *
FROM EMP
WHERE DEPTNO <> 10;

SELECT *
FROM EMP
WHERE DEPTNO ^= 10;

--Q8

SELECT *
FROM EMP
WHERE SAL >= 1000
AND SAL<=1500
ORDER BY EMPNO;


SELECT *
FROM EMP
WHERE SAL BETWEEN 1000 AND 1500
ORDER BY EMPNO;

--Q9

SELECT *
FROM EMP
WHERE SAL < 1000
OR SAL >1500
ORDER or EMPNO;

SELECT *
FROM EMP
WHERE SAL NOT BETWEEN 1000 AND 1500
ORDER BY EMPNO;

SELECT *
FROM EMP
WHERE SAL < 1000
UNION
SELECT *
FROM EMP
WHERE SAL > 1500
ORDER BY EMPNO;

--Q10

SELECT *
FROM EMP
WHERE COMM = 300
   OR COMM = 500
   OR COMM = 1400;

SELECT *
FROM EMP
WHERE COMM IN(300,500,1400);

-- 연습문제 코드

// 1)
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 20 
OR DEPTNO = 30
AND SAL > 2000;

// 2)
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 20
AND SAL > 2000
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO = 30
AND SAL > 2000;


SELECT *
FROM EMP
WHERE COMM IS NULL
AND MGR IS NOT NULL
AND (JOB = 'MANAGER' OR JOB = 'CLERK')
AND SUBSTR(ENAME, 2, 1) != 'L';

SELECT *
FROM EMP
WHERE COMM IS NULL
AND MGR IS NOT NULL
AND (JOB = 'MANAGER' OR JOB = 'CLERK')
AND ENAME NOT LIKE '_L%';

SELECT *
FROM EMP
WHERE COMM IS NULL
AND MGR IS NOT NULL
AND JOB IN ('MANAGER', 'CLERK')
AND SUBSTR(ENAME, 2, 1) != 'L';


-- Q6장-2 연습문제
SELECT EMPNO, ENAME, SAL,
    TRUNC(SAL / 21.5, 2) AS "DAILY_SALARY",  
    ROUND((SAL / 21.5) / 8, 1) AS "HOURLY_WAGE"  
FROM EMP;

-- 6장 Q-3 연습문제

SELECT
    EMPNO,
    ENAME,
    TO_CHAR(HIREDATE, 'YYYY/DD/MM') AS HIREDATE,
    TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE, 3), '월요일'), 'YYYY-MM-DD') AS R_JOB,
    NVL2(COMM, TO_CHAR(COMM), 'N/A') AS COMM
FROM EMP
ORDER BY EMPNO;

-- 6장 Q4 연습문제

SELECT EMPNO, ENAME, MGR,
       CASE 
           WHEN MGR IS NULL THEN '0000'
           WHEN TO_CHAR(MGR) LIKE '75%' THEN '5555'
           WHEN TO_CHAR(MGR) LIKE '76%' THEN '6666'
           WHEN TO_CHAR(MGR) LIKE '77%' THEN '7777'
           WHEN TO_CHAR(MGR) LIKE '78%' THEN '8888'
           ELSE TO_CHAR(MGR)
       END AS "CHG_MGR"
FROM EMP;

--7장 연습문제 Q1.

SELECT DEPTNO,
    TRUNC(AVG(SAL)) AS "AVG_SAL",
    TRUNC(MAX(SAL)) AS "MAX_SAL",
    TRUNC(MIN(SAL)) AS "MIN_SAL",
    COUNT(SAL) AS "CNT"
FROM EMP
GROUP BY DEPTNO;

--7장 연습문제 02.

SELECT JOB, -- 직책
    COUNT(JOB) AS "COUNT(*)" -- 직책 별 종사 인원
FROM EMP
GROUP BY JOB -- JOB으로 그룹
HAVING COUNT(JOB) >= 3; -- 종사 인원이 3명 이상일 때


--7장 연습문제 03.

SELECT TO_CHAR(HIREDATE, 'YYYY') AS "HIRE_YEAR", --YYYY 형식으로 입사 년도 문자열 변환
    DEPTNO,
    COUNT(HIREDATE) AS "CNT" -- 입사 년도별 카운트
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO; -- 입사 년도 형식 변환 그룹핑


--7장 연습문제 04.

SELECT *
FROM EMP;

SELECT
    NVL2(COMM,'O','X') AS "EXIST_COMM", -- NULL 일 때는 X, NULL 이 아닐떄는 O
    COUNT(*) AS "CNT" -- NULL 포함하여 카운팅
FROM EMP
GROUP BY NVL2(COMM,'O','X'); -- NULL 일 때는 X, NULL 이 아닐떄는 O 로 그룹


--7장 연습문제 05

SELECT DEPTNO,
    TO_CHAR(HIREDATE, 'YYYY') AS "HIRE_YEAR",
    COUNT(*) AS "CNT",
    MAX(SAL) AS "MAX_SAL",
    SUM(SAL) AS "SUM_SAL",
    ROUND(AVG(SAL),11) AS "AVG_SAL" --소수점 11번째 자리로 반올림
FROM EMP
GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY')); --ROLLUP 함수를 이용하여 그룹화 데이터의 소계, 합계를 출력한다.


-- 8장 연습문제 Q1

--SQL-99 이전 방식

SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E, DEPT D 
WHERE E.DEPTNO=D.DEPTNO -- 등가 조인
AND SAL>=2000
ORDER BY E.DEPTNO; -- DEPTNO으로 오름차순 정렬인

--SQl-99 이후 방식

SELECT DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM EMP NATURAL JOIN DEPT -- NATURAL JOIN
WHERE SAL >= 2000
ORDER BY DEPTNO; --오름차순 정렬


-- 8장 연습문제 Q2

--SQL-99 이전 방식

SELECT E.DEPTNO, D.DNAME,
    TRUNC(AVG(E.SAL)) AS "AVG_SAL", -- 소수점 첫번째 자리 버림
    MAX(E.SAL) AS "MAX_SAL",
    MIN(E.SAL) AS "MIN_SAL",
    COUNT(E.JOB) AS "CNT"
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
GROUP BY D.DNAME,E.DEPTNO
ORDER BY DEPTNO;

--SQl-99 이후 방식
-- NATURAL JOIN
SELECT DEPTNO, DNAME,
    ROUND(AVG(SAL)) AS "AVG_SAL",
    MAX(SAL) AS "MAX_SAL",
    MIN(SAL) AS "MIN_SAL",
    COUNT(JOB) AS "CNT"
FROM EMP NATURAL JOIN DEPT
GROUP BY DEPTNO, DNAME
ORDER BY DEPTNO;


SELECT E.DEPTNO, D.DNAME,
    ROUND(AVG(E.SAL)) AS "AVG_SAL",
    MAX(E.SAL) AS "MAX_SAL",
    MIN(E.SAL) AS "MIN_SAL",
    COUNT(E.JOB) AS "CNT"
FROM EMP E JOIN DEPT D USING (DEPTNO)
GROUP BY E.DEPTNO, D.DNAME
ORDER BY E.DEPTNO, D.DNAME;


-- 8장 연습문제 Q3

--SQL-99 이전 방식

SELECT *
FROM DEPT;

SELECT *
FROM EMP;

SELECT E.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO --오른쪽 외부 조인
ORDER BY E.DEPTNO, E.ENAME;

--SQl-99 이후 방식

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E RIGHT OUTER JOIN DEPT D ON (E.DEPTNO=D.DEPTNO) -- RIGHT OUTER JOIN
ORDER BY E.DEPTNO, E.ENAME;


--1) SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY D.DEPTNO, E.ENAME;

--2) SQL-99 방식
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E RIGHT OUTER JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
ORDER BY D.DEPTNO, E.ENAME;




-- 8장 연습문제 Q4

--1) SQL-99 이전 방식
SELECT D.DEPTNO, D.DNAME,
    E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO,
    S.LOSAL, S.HISAL, S.GRADE,
    E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E, DEPT D, SALGRADE S, EMP E2
WHERE E.DEPTNO(+) = D.DEPTNO
    AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
    AND E.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO, E.EMPNO;
